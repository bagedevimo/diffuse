// Copyright 2018 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.


use futures::{
    future::{self, Ready},
};
use std::{io, net::SocketAddr};
use tarpc::{
    context,
    server::{Handler, Server},
};

// This is the type that implements the generated Service trait. It is the business logic
// and is used to start the server.
#[derive(Clone)]
struct DiffuseServer;

impl crate::proto::Service for DiffuseServer {
    // Each defined rpc generates two items in the trait, a fn that serves the RPC, and
    // an associated type representing the future output by the fn.
    type HelloFut = Ready<String>;
    type StoreBlobFut = Ready<bool>;

    fn hello(self, _: context::Context, name: String) -> Self::HelloFut {
        future::ready(format!("Hello, {}!", name))
    }

    fn store_blob(self, _: context::Context, blob: crate::git::Record) -> Self::StoreBlobFut {
        eprintln!("Done storing on server");
        future::ready(true)
    }
}

pub async fn run(server_addr: SocketAddr) -> io::Result<()> {
    // bincode_transport is provided by the associated crate bincode-transport. It makes it easy
    // to start up a serde-powered bincode serialization strategy over TCP.
    let transport = tarpc_bincode_transport::listen(&server_addr)?;

    // The server is configured with the defaults.
    let server = Server::default()
        // Server can listen on any type that implements the Transport trait.
        .incoming(transport)
        // serve is generated by the service! macro. It takes as input any type implementing
        // the generated Service trait.
        .respond_with(crate::proto::serve(DiffuseServer));

    server.await;

    Ok(())
}
