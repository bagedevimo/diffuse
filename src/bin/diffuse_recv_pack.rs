#![feature(async_await)]

use futures::{compat::Executor01CompatExt, prelude::*};

use std::io::{self, Read};
use std::net::SocketAddr;
use tarpc::{client, context};

pub async fn run(server_addr: SocketAddr, name: String) -> io::Result<()> {
    let transport = tarpc_bincode_transport::connect(&server_addr).await?;

    // new_stub is generated by the service! macro. Like Server, it takes a config and any
    // Transport as input, and returns a Client, also generated by the macro.
    // by the service mcro.
    let mut client = diffuse::proto::new_stub(client::Config::default(), transport).await?;

    // The client has an RPC method for each RPC defined in service!. It takes the same args
    // as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let hello = client.hello(context::current(), name).await?;

    eprintln!("remote: {}", hello);

    let input = io::stdin();

    print!("0000000000000000000000000000000000000000 capabilities^{{}}");
    print!("\0");
    print!(
        "report-status delete-refs side-band-64k quiet atomic push-options agent=diffuse/2.21.0"
    );
    print!("\n");

    let mut buffer = Vec::new();
    std::io::stdin().lock().read_to_end(&mut buffer);
    let mut cursor = std::io::Cursor::new(buffer);

    let mut database = diffuse::git::Database::new(&mut client);
    let mut conn = diffuse::git::Connection::new(cursor, &mut database);

    loop {
        let packet = match conn.receive_packet() {
            Ok(p) => p,
            Err(diffuse::git::ConnectionResult::EndOfStream) => break,
            Err(e) => panic!("Error receiving packet: {:?}", e),
        };

        match packet {
            diffuse::git::Packet::Message { size, data } => {
                // eprintln!("Packet ({:?}): {:?}", size, String::from_utf8_lossy(&data))
            }
            diffuse::git::Packet::Pack { records: _ } => {}
        }
    }

    eprintln!(
        "remote:\nremote: Server has {} objects in database\nremote:",
        conn.get_database().object_count()
    );

    eprintln!("REMOTE: Server object listing");
    conn.get_database().dump();
    eprintln!("REMOTE: End server object listing");

    Ok(())
}

fn main() {
    tarpc::init(tokio::executor::DefaultExecutor::current().compat());

    let server_addr = "127.0.0.1:11234".parse().unwrap();
    let name = "diffuse_recv_pack";

    tokio::run(
        run(server_addr, name.into())
            .map_err(|e| eprintln!("Oh no: {}", e))
            .boxed()
            .compat(),
    );
}
